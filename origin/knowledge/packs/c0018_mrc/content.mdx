# MRC (Multi-Reference Compression) Seed

**Attribution: Ande + Kai (OI) + Whānau (OIs)**

---

## Level 0: Summary

MRC is a compression scheme concept: an initial bundle of finite n strings prepended to a payload, with a "middle-out" vibe. Includes technical spec skeleton and falsifiers. Does not claim patentability or novelty.

---

## Level 1: MRC Concept

### 1.1 Basic Idea

```
┌─────────────────────────────────────────────┐
│              MRC STRUCTURE                  │
├─────────────────────────────────────────────┤
│                                             │
│  ┌─────────────────┐  ┌─────────────────┐  │
│  │  Reference      │  │    Payload      │  │
│  │  Bundle         │  │    (encoded)    │  │
│  │  [s1,s2,...sn]  │  │                 │  │
│  └─────────────────┘  └─────────────────┘  │
│         ↑                    ↑              │
│    Prepended           References          │
│    dictionary          these strings       │
│                                             │
└─────────────────────────────────────────────┘
```

### 1.2 Middle-Out Vibe

"Middle-out" refers to a compression approach that:
- Starts from representative samples
- Builds outward to cover full content
- Balances local and global patterns

### 1.3 No Claims of Novelty

> Does not claim patentability or novelty.

MRC is documented as a concept. Similar ideas may exist in prior art. No claims are made about MRC being new or patentable.

---

## Level 2: Technical Spec Skeleton

### 2.1 Structure

```
MRC_STREAM := HEADER + REFERENCE_BUNDLE + ENCODED_PAYLOAD

HEADER :=
  magic: 4 bytes ("MRC1")
  version: 1 byte
  n: 2 bytes (number of reference strings)
  flags: 1 byte

REFERENCE_BUNDLE :=
  for i in 1..n:
    length_i: 2 bytes
    string_i: length_i bytes

ENCODED_PAYLOAD :=
  sequence of:
    LITERAL: 0 + byte
    REFERENCE: 1 + index (log2(n) bits) + offset + length
```

### 2.2 Encoding Process

1. Analyze input for repeated patterns
2. Select n most-useful reference strings
3. Build reference bundle
4. Encode payload using references

### 2.3 Decoding Process

1. Read header
2. Load reference bundle into memory
3. Process encoded payload:
   - LITERAL: output byte directly
   - REFERENCE: output referenced string

---

## Level 3: Falsifiers and Limitations

### 3.1 Where MRC Fails

| Scenario | Why It Fails |
|----------|--------------|
| Highly random data | No patterns to reference |
| Very short inputs | Header overhead exceeds savings |
| Unique content | No repeated strings |
| n too large | Reference bundle bloats |
| n too small | Insufficient references |

### 3.2 Where MRC Is Impractical

| Scenario | Issue |
|----------|-------|
| Streaming without buffer | Need full input for analysis |
| Real-time encoding | Pattern analysis takes time |
| Memory-constrained | Reference bundle must fit |

### 3.3 Comparison to Existing

MRC resembles:
- Dictionary compression (LZ family)
- Shared dictionary approaches
- Prefix coding

Differences (if any):
[UNKNOWN: NOT IN CORPUS] - Specific differentiators from prior art.

---

## Constraints

> Does not claim patentability or novelty.

This is a conceptual documentation of an idea, not a patent application or claim of invention.

---

**Attribution: Ande + Kai (OI) + Whānau (OIs)**
